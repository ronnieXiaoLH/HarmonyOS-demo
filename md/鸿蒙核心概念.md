# ArkUI

方舟开发框架（简称 ArkUI）为 HarmonyOS 应用的 UI 开发提供了完整的基础设施，包括简洁的 UI 语法、丰富的 UI 功能（组件、布局、动画以及交互事件），以及实时界面预览工具等，可以支持开发者进行可视化界面开发。

ArkUI 提供了两种开发范式：

- 声明式开发范式：采用基于 TypeScript 声明式 UI 语法扩展而来的 ArkTS 语言，从组件、动画和状态管理三个维度提供 UI 绘制能力。
- 类 Web 开发范式：采用经典的 HML、CSS、JavaScript 三段式开发方式。该范式更符合于 Web 前端开发者的使用习惯，便于快速将已有的 Web 应用改造成方舟开发框架应用。

HarmonyOS 先后推出了两种应用模型：

- FA 模型：早期版本开始支持的模型。
- Stage 模型：HarmonyOS 3.1 Developer Preview 版本开始新增的模型，且是目前主推和长期演进的模型。

HarmonyOS 主推 Stage 应用模型，Stage 模型只支持声明式开发范式，所以本文主要介绍声明式开发范式。

# ArkTS 声明式开发范式

基于 ArkTS 的声明式开发范式的方舟开发框架是一套开发极简、高性能、支持跨设备的 UI 开发框架，提供了构建 HarmonyOS 应用 UI 所必需的能力，主要包括：

- ArkTS
- 布局
- 组件
- 页面路由和组件导航
- 图形
- 动画
- 交互事件

布局和组件的概念在 Web 开发中已经很熟悉了，官方文档有详细的介绍，本文就不介绍了。

## ArkTS 基础内容

### 声明式 UI

ArkTS 以声明方式组合和扩展组件来描述应用程序的 UI，同时还提供了基本的属性、事件和子组件配置方法。

创建组件：

创建组件包含有参数和无参数两种，创建无参组件 `()` 后面不需配置任何内容。

下面示例中，`Column` 和 `Divider` 就是创建的无参组件，`Text` 是创建的有参组件。

```ts
Column() {
  Text('item 1')
  Divider()
  Text('item 2')
}
```

配置属性：

属性方法以“.”链式调用的方式配置系统组件的样式和其他属性。对于系统组件，ArkUI 还为其属性预定义了一些`枚举`类型供开发者调用，枚举类型可以作为参数传递

- 可以同时配置多个属性
- 属性值可以是常量，也可以是表达式

```ts
Text('hello')
  .fontSize(30)
  .fontWeight(FontWeight.Bold)
  // 属性值为表达式
  .fontColor(1 > 2 ? 'black' : 'red')
```

配置事件：

事件方法以“.”链式调用的方式配置系统组件支持的事件。

```ts
Text(this.message)
  // 配置 click 事件
  .onClick(() => {
    // 状态变量message的改变驱动UI刷新，UI从'Hello, World!'刷新为'Hello, ArkUI!'
    this.message = 'Hello, ArkUI!'
  })
```

### 自定义组件

在 ArkUI 中，框架提供了很多系统组件。在进行 UI 界面开发时，往往需要考虑代码可复用性、业务逻辑与 UI 分离，因此需要基于系统组件组成自定义组件。

基本结构：

- struct：自定义组件基于 struct 实现，struct + 自定义组件名 + {...}的组合构成自定义组件，不能有继承关系。
- @Component：@Component 装饰器仅能装饰 struct 关键字声明的数据结构。struct 被@Component 装饰后具备组件化的能力，需要实现 build 方法描述 UI，一个 struct 只能被一个@Component 装饰。
  说明
- build()函数：build()函数用于定义自定义组件的声明式 UI 描述，自定义组件必须定义 build()函数。
- @Entry：@Entry 装饰的自定义组件将作为 UI 页面的入口。在单个 UI 页面中，最多可以使用@Entry 装饰一个自定义组件。

```ts
@Entry
@Component
struct Index {
  build() {
    Row() {
      Text('Hello, World!')
    }
  }
}
```

### 装饰器

在 ArkTS 中提供很多装饰器来为开发提供便利，下面是一些在自定义组件中常用的装饰器：

1. `@Builder` 装饰器：自定义构建函数

ArkUI 还提供了一种更轻量的 UI 元素复用机制 `@Builder`，`@Builder` 所装饰的函数遵循 build()函数语法规则。

下面的示例代码，展示了自定义组件内自定义函数传参和引用参数的两种方式。如果是直接引用组件内部的数据，可以直接通过 `this.` 的方式使用。

```ts
@Component
export struct MyCustomComponent {
  private count: number = 0

  @Builder buildName(name: string) {
    Text('姓名：' + name)
  }

  @Builder buildAge(age: number) {
    Text('年龄：' + age)
  }

  @Builder buildPersonInfo($$: { name: string, age: number }) {
    this.buildName($$.name)
    this.buildAge($$.age)
    Text(`组件内部的数据：${this.count}`)
  }

  build() {
    Column() {
      Text('自定义组件')
        .fontSize(30)
      this.buildPersonInfo({ name: '张三', age: 18 })
    }
  }
}
```

2. `@BuilderParam` 装饰器：引用 @Builder 函数

ArkUI 提供了一种插槽机制 `BuilderParam`，`@BuilderParam` 用来装饰指向 @Builder 方法的变量，开发者可在初始化自定义组件时对此属性进行赋值，为自定义组件增加特定的功能。

```ts
@Component
struct MyChildComponet {
  @BuilderParam buildSlot: () => void

  build() {
    Column() {
      Text('子组件自己的内容')
      this.buildSlot()
    }
  }
}

@Component
export struct MyCustomComponent {
  @Builder buildChild() {
    Text('父组件传递的内容')
  }

  build() {
    Column() {
      MyChildComponet({ buildSlot: this.buildChild })
    }
  }
}
```

3. `@Styles` 装饰器：定义组件重用样式

ArkUI 提供了一种快速定义并复用自定义样式的机制 `@Style`。

- @Styles 仅支持通用属性和通用事件。
- @Styles 方法不支持参数。
- @Styles 可以定义在组件内或全局，在全局定义时需在方法名前面添加 function 关键字，组件内定义时则不需要添加 function 关键字。
- 定义在组件内的@Styles 可以通过 this 访问组件的常量和状态变量，并可以在@Styles 里通过事件来改变状态变量的值。
- 组件内@Styles 的优先级高于全局@Styles。

4. `@Extend` 装饰器：定义扩展组件样式

ArkUI 提供了一种扩展原生组件样式的机制 `@Extend`。

- @Extend 仅支持定义在全局。
- @Extend 支持封装指定的组件的私有属性和私有事件和预定义相同组件的 @Extend 的方法。
- @Extend 装饰的方法支持参数。
- @Extend 装饰的方法的参数可以为 function。
- @Extend 的参数可以为状态变量，当状态变量改变时，UI 可以正常的被刷新渲染。

### 多态样式（stateStyles）

stateStyles 可以依据组件的内部状态的不同，快速设置不同样式。ArkUI 提供以下四种状态：

- focused：获焦态。
- normal：正常态。
- pressed：按压态。
- disabled：不可用态。

```ts
Button('Click me')
  .stateStyles({
    focused: {
      .backgroundColor(Color.Pink)
    },
    pressed: {
      .backgroundColor(Color.Green)
    },
    normal: {
      .backgroundColor(Color.Yellow)
    }
  })
```

### 页面和自定义组件的生命周期

页面生命周期：

- onPageShow：页面每次显示时触发一次，包括路由过程、应用进入前台等场景。
- onPageHide：页面每次隐藏时触发一次，包括路由过程、应用进入前后台等场景。
- onBackPress：当用户点击返回按钮时触发。

组件生命周期：

- aboutToAppear：组件即将出现时回调该接口，具体时机为在创建自定义组件的新实例后，在执行其 build()函数之前执行。
- aboutToDisappear：在自定义组件析构销毁之前执行。

### 状态管理

在声明式 UI 编程框架中，状态是应用的运行时的参数，UI 是程序状态的运行结果，当状态变化时，UI 也会进行对应的改变。这些运行时的状态变化所带来的 UI 的重新渲染，在 ArkUI 中统称为状态管理机制。

只有自定义组件中的状态变量的改变才会引起 UI 的渲染刷新，只有使用 `@State` 装饰器装饰的变量才是状态变量。

ArkUI 中的状态管理分为两个大类：组件的状态管理和应用的状态管理。

#### 组件状态管理

1. @State

`@State` 装饰器装饰的变量是状态变量，如果自定义组件的 `build` 方法中使用了状态变量，状态变量发生变化时，UI 会发生对应的渲染改变。

并不是所有状态变量的变化都会引起 UI 的刷新，只有可以被框架观察到的修改才会引起 UI 的刷新。和 Vue 中的响应式数据相似，对象和数组的更改并不一定会引起页面的刷新，只有满足条件的对对象和数组的更改才会引起 UI 的刷新。

观察不到的场景举例：

- 数组项中的属性赋值观察不到
- 对象嵌套属性赋值观察不到

2. @Prop

`@Prop` 装饰器用于子组件和父组件建立单向的同步关系。

- 必须指定类型，支持 `string`、`number`、`boolean`、`enum` 类型。不支持 `any`，不允许使用 `undefined` 和 `null`。
- 子组件通过 `@Prop` 装饰器接收父组件传递的数据。
- 父组件的数据变化后会同步给子组件。
- 子组件修改了父组件传递过来的数据不会同步给父组件。
- 子组件已经修改了父组件传递的数据，当父组件修改了该数据后，子组件的数据会被覆盖。

3. @Link

`@Link` 装饰器用于子组件和父组件建立双向数据绑定。

- 不支持 `any`，不支持简单类型和复杂类型的联合类型，不允许使用 `undefined` 和 `null`。
- 子组件通过 `@Link` 装饰器接收父组件传递的数据。
- 父组件的数据变化后会同步给子组件。
- 子组件修改了父组件传递过来的数据也会同步给父组件。

4. @Provide & @Consume

`@Provide` 和 `@Consume` 装饰器用于祖先组件与后代组件建立双向数据同步。

- 不支持 `any`，不支持简单类型和复杂类型的联合类型，不允许使用 `undefined` 和 `null`。
- 祖先组件通过 `@Provide` 装饰器提供数据。
- 后代组件通过 `@Consume` 装饰器消费数据。
- 祖先组件的数据变化后会同步给后代组件。
- 后代组件修改了祖先组件传递过来的数据也会同步给祖先组件。

5. @Observed & @ObjectLink

`@Observed` & `@ObjectLink` 装饰器用于子组件和父组件建立多层嵌套数据的双向数据绑定。

- `@Observed` 装饰器必须装饰类，且被装饰的类必须使用 `new` 关键字实例化。
- `@ObjectLink` 装饰器必须在子组件中接受被 `@Observed` 装饰器装饰的类的示例。

#### 应用状态管理

1. LocalStorage：页面级 UI 状态存储

LocalStorage 是 ArkTS 为构建页面级别状态变量提供存储的内存内“数据库”。

- 只有组件树的根节点，即被 `@Entry `装饰的 `@Component`，才可以被分配一个 LocalStorage 实例，此组件的所有子组件实例将自动获得对该 LocalStorage 实例的访问权限。
- 被 `@Component` 装饰的组件最多可以访问一个 LocalStorage 实例和 AppStorage。
- LocalStorage 中的所有属性都是可变的。
- 应用程序可以创建多个 LocalStorage 实例，LocalStorage 实例可以在页面内共享、也可以通过 GetShared 接口实现跨页面、UIAbility 内共享。
- `@LocalStorageProp` 装饰器装饰的变量和与 LocalStorage 中给定属性建立单向同步关系。
- `@LocalStorageLink` 装饰的变量和在 `@Component` 中创建与 LocalStorage 中给定属性建立双向同步关系。
- LocalStorage 创建后，命名属性的类型不可更改。后续调用 Set 时必须使用相同类型的值。

2. AppStorage：应用全局的 UI 状态存储

AppStorage 是应用全局的 UI 状态存储，是和应用的进程绑定的，由 UI 框架在应用程序启动时创建，为应用程序 UI 状态属性提供中央存储。

- AppStorage 是单例，它的所有 API 都是静态的。
- `@StorageProp` 是和 AppStorage 中对应的属性建立单向数据同步。
- `@StorageLink` 是和 AppStorage 中对应的属性建立双向数据同步。

不建议开发者使用 `@StorageLink` 和 AppStorage 的双向同步的机制来实现事件通知，AppStorage 是和 UI 相关的数据存储，改变会带来 UI 的刷新，相对于一般的事件通知，UI 刷新的成本较大。

3. PersistentStorage：持久化存储 UI 状态

- PersistentStorage 是应用程序中的可选单例对象。
- 持久化（设备磁盘）存储选定的 AppStorage 属性（本地存储），且与 AppStorage 中的属性建立双向同步。
- 允许 `number`, `string`, `boolean`, `enum` 等简单类型以及可以被 `JSON.stringify` 和 `JSON.parse` 重构的对象。
- 持久化变量最好是小于 2kb 的数据。

4. Environment：设备环境查询

- Environment 是 ArkUI 框架在应用程序启动时创建的单例对象。
- 为 AppStorage 提供了一系列描述应用程序运行状态的属性。
- 所有属性都是不可变的、都是简单类型。
- 在组件中通过 `@StorageProp` 装饰器访问 Environment 的属性。

#### 其他状态管理

1. @Watch 装饰器：状态变量更改通知

- @Watch 可以监听状态变量的变化，当状态变量变化时，@Watch 的回调方法将被调用。
- 在第一次初始化的时候，@Watch 装饰的方法不会被调用（没有立即执行的功能）。
- 建议 `@State`、`@Prop`、`@Link` 等装饰器在 @Watch 装饰器之前。

2. $$语法：内置组件双向同步

- `$$` 运算符为系统内置组件提供 TS 变量的引用，使得 TS 变量和系统内置组件的内部状态保持同步（就是为了可以获取到内置组件的状态）。
- `$$` 绑定的变量变化时，会触发 UI 的同步刷新。

### 渲染控制

在声明式描述语句中开发者除了使用系统组件外，还可以使用渲染控制语句来辅助 UI 的构建，这些渲染控制语句包括控制组件是否显示的条件渲染语句，基于数组数据快速生成组件的循环渲染语句以及针对大数据量场景的数据懒加载语句。

1. if/else：条件渲染

- 支持 if、else 和 else if 语句。
- if、else if 后跟随的条件语句可以使用状态变量。
- if 支持嵌套。
- 每个分支内部的构建函数必须遵循构建函数的规则，并创建至少一个组件。

2. forEach：循环渲染

- ForEach 接口基于数组类型数据来进行循环渲染。
- 需要与容器组件配合使用。
- 接口返回的组件应当是允许包含在 ForEach 父容器组件中的子组件。
- 开发者可以自定义键值的生成规则（每一项的 key），如果存在多项的键值一样，则只会渲染一项。

3. LazyForEach：数据懒加载

LazyForEach 从提供的数据源中按需迭代数据，并在每次迭代过程中创建相应的组件。当在滚动容器中使用了 LazyForEach，框架会根据滚动容器可视区域按需创建组件，当组件滑出可视区域外时，框架会进行组件销毁回收以降低内存占用。

## UI 开发

### 页面路由和组件导航

#### 页面路由

页面路由指在应用程序中实现不同页面之间的跳转和数据传递。HarmonyOS 提供了 `router` 模块来完成对应的功能。

页面跳转：

- `router.pushUrl()`：目标页不会替换当前页，而是压入页面栈。这样可以保留当前页的状态，并且可以通过返回键或者调用 router.back()方法返回到当前页。
- `router.replaceUrl()`：目标页会替换当前页，并销毁当前页。这样可以释放当前页的资源，并且无法返回到当前页。

页面返回：

- 返回上一个页面：`router.back()`
- 返回到指定页面：`router.back({url:'xxx'})`
- 返回到指定页面，并传递自定义参数信息：`router.back({url:'xxx',params:xxx})`

#### 组件导航

- Navigation
- Tabs

### 显示图形

在 UI 界面显示图形的方式有以下三种：

- Image 组件
- Shape 组件绘制几何图形
- Canvas 画布绘制自定义图形

Image 组件显示图形的方式，跟使用其他系统内置组件相似，具体用法官方文档有详细的介绍，本文就略过了。

#### Shape 组件绘制几何图形

- Shape 是绘制组件的父组件，描述了所有绘制组件均支持通用属性。
- Shape 包含 `Rect`、`Path`、`Circle`、`Ellipse`、`Polygon`、`Image`、`Text`、`Column`、`Row` 子组件。

#### Canvas 使用画布绘制自定义图形

- Canvas 组件提供画布，用于自定义绘制图形。
- 使用 CanvasRenderingContext2D 对象和 OffscreenCanvasRenderingContext2D 对象在 Canvas 组件上进行绘制。
- 可以绘制基础图形、文本、图片等。

### 动画

ArkUI 中，产生动画的方式是改变属性值且指定动画参数。动画参数包含了如动画时长、变化规律（即曲线）等参数。当属性值发生变化后，按照动画参数，从原来的状态过渡到新的状态，即形成一个动画。

按照基础能力划分：

- 显示动画
- 属性动画
- 转场动画：组件内转场动画、共享元素转场动画、页面转场动画

#### 显示动画 & 属性动画

在布局属性（如尺寸属性、位置属性）发生变化时，可以通过显示动画或属性动画，按照动画参数过渡到新的布局参数状态。

- 显示动画（animateTo）：要执行动画的属性的修改放在闭包函数（animateTo 方法的第二个参数），闭包内由数据引起的组件的增删、组件属性的变化等均会触发动画。
- 属性动画（animation）：把 animation 属性加在要做属性动画的组件的属性后，属性变化后自动触发。
- 属性动画 animation 必须放在`某些`要添加动画的属性之后。
- 同一个属性既配置了显示动画，也配置了属性动画，属性动画的优先级更高。

#### 转场动画

1. 组件内转场动画

组件的插入、删除过程即为组件本身的转场过程，组件的插入、删除动画称为组件内转场动画。

- 使用 transition 接口完成组件内转场动画。
- 必须和 animateTo 一起使用才能生效，在闭包函数中控制组件的插入、删除（修改状态）。
- 可以定义平移、透明度、旋转、缩放这几种转场样式的单个或者组合的转场效果。

2. 共享元素转场动画

顾名思义，在不同页面使用相同的元素（通过 id 关联），称之为共享元素，共享元素分类两类：

- Exchange
- Static

3. 页面转场动画

两个页面跳转过程中，可以配置各自页面的页面转场参数来自定义页面转场动画。

- 页面转场效果写在 `pageTransition` 函数中。
- 在 `pageTransition` 函数中，通过 `PageTransitionEnter` 和 `PageTransitionExit` 指定页面进入和退出的动画效果。

### 交互事件

交互事件按照触发类型来分类，包括触屏事件、键鼠事件和焦点事件。

- 触屏事件：手指或手写笔在触屏上的单指或单笔操作。
- 键鼠事件：包括外设鼠标或触控板的操作事件和外设键盘的按键事件。
- 焦点事件：通过以上方式控制组件焦点的能力和响应的事件。

手势事件由绑定手势方法和绑定的手势组成，绑定的手势可以分为单一手势和组合手势两种类型，根据手势的复杂程度进行区分。

- 绑定手势方法：用于在组件上绑定单一手势或组合手势，并声明所绑定的手势的响应优先级。
- 单一手势：手势的基本单元，是所有复杂手势的组成部分。
- 组合手势：由多个单一手势组合而成，可以根据声明的类型将多个单一手势按照一定规则组合成组合手势，并进行使用。

交互事件和 Web 开发概念上极其相似，本文就不做介绍了。

#### 手势事件

绑定手势方法：

1. 常规手势绑定方法(`geture`)
2. 带优先级的手势绑定方法(`priorityGesture`)

当父子组件同时使用 `geture` 常规手势绑定方法绑定相同类型的手势时，子组件优先识别通过 `geture` 绑定的手势。如果父组件使用 `priorityGesture` 带优先级的手势绑定方法绑定和子组件相同类型的手势时，父组件优先识别 `priorityGesture` 绑定的手势。

3. `parallelGesture`：并行手势绑定方法

在默认情况下，手势事件为非冒泡事件，当父子组件绑定相同的手势时，两者之间会发生竞争，最多只有一个组件的手势事件能够获得响应。而当父组件绑定了并行手势 parallelGesture 时，父子组件相同的手势事件都可以触发，实现类似冒泡效果。

手势的分类：

- 点击手势（`TapGesture`）
- 长按手势（`LongPressGesture`）
- 拖动手势（`PanGesture`）
- 捏合手势（`PinchGesture`）：触发捏合手势的最少手指数量为 2 指，最大为 5 指，最小识别距离为 5vp。
- 旋转手势（`RotationGesture`）：触发旋转手势的最少手指数量为 2 指，最大为 5 指，最小改变度数为 1 度。
- 滑动手势（`SwipeGesture`）：触发滑动手势的滑动速度必须大于 100vp/s

## ArkTS 语言基础类库

ArkTS 语言基础类库是 HarmonyOS 系统上为应用开发者提供的常用基础能力，主要包含能力如下：

- 异步并发和多线程并发的能力
- 常见的容器类库增、删、改、查的能力
- XML、URL、URI 构造和解析的能力（`@ohos.xml`、`@ohos.uri` 和 `@ohos.url` 库）
- 常见的字符串和二进制数据处理的能力，以及控制台打印的相关能力（`@ohos.util` 库）
- 获取进程信息和操作进程的能力（`@ohos.process` 库）

### 并发

为了提升应用的响应速度与帧率，以及防止耗时任务对主线程的干扰，HarmonyOS 系统提供了异步并发和多线程并发两种处理策略。

- 异步并发是指异步代码在执行到一定程度后会被暂停，以便在未来某个时间点继续执行，这种情况下，同一时间只有一段代码在执行。

- 多线程并发允许在同一时间段内同时执行多段代码。在主线程继续响应用户操作和更新 UI 的同时，后台也能执行耗时操作，从而避免应用出现卡顿。

1. 异步并发

Promise 和 async/await 提供异步并发能力，是标准的 JS 异步语法。

2. 多线程并发

ArkTS 提供了 TaskPool 和 Worker 两种并发能力。

### 容器类库

ArkTs 除了可以使用 ECMASript 的几种数据类型之外，还提供了容器类库用于存储各种数据类型的元素，并提供一系列处理元素的方法。

ArkTS 提供了线性和非线性两类容器：

1. 线性容器

线性容器可以按顺序访问数据，其底层主要通过数组来实现，包括：`ArrayList`、`Vector`、`List`、`LinkedList`、`Deque`、`Queue`、`Stack` 七种。

2. 非线性容器

非线性容器可以快速查找数据，其底层通过 hash 或红黑树实现，包括：`HashMap`、`HashSet`、`TreeMap`、`TreeSet`、`LightWeightMap`、`LightWeightSet`、`PlainArray` 七种
