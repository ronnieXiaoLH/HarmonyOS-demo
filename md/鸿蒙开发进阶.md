# Stage 模型

下图是 Stage 模型概念图

![Stage 模型概念图](D:\my-code\mobile-terminal-project\harmonyos-project\harmonyosDemo\md\images\Stage模型概念图.png)

- UIAbility 组件和 ExtensionAbility 组件

  Stage 模型提供 UIAbility 和 ExtensionAbility 两种类型的组件，这两种组件都有具体的类承载，支持面向对象的开发方式。

  - UIAbility 组件是一种包含 UI 界面的应用组件，主要用于和用户交互。
  - ExtensionAbility 组件是一种面向特定场景的应用组件。

- WindowStage

  每个 UIAbility 类实例都会与一个 WindowStage 类实例绑定，该类提供了应用进程内窗口管理器的作用。它包含一个主窗口。也就是说 UIAbility 通过 WindowStage 持有了一个窗口，该窗口为 ArkUI 提供了绘制区域。

- Context

  在 Stage 模型上，Context 及其派生类向开发者提供在运行期可以调用的各种能力。UIAbility 组件和各种 ExtensionAbility 派生类都有各自不同的 Context 类，他们都继承自基类 Context，但是各自又根据所属组件，提供不同的能力。

- AbilityStage

  每个 Entry 类型或者 Feature 类型的 HAP 在运行期都有一个 AbilityStage 类实例，当 HAP 中的代码首次被加载到进程中的时候，系统会先创建 AbilityStage 实例。每个在该 HAP 中定义的 UIAbility 类，在实例化后都会与该实例产生关联。开发者可以使用 AbilityStage 获取该 HAP 中 UIAbility 实例的运行时信息。

## AbilityStage 组件容器

- AbilityStage 是一个 Module 级别的组件容器，应用的 HAP 在首次加载时会创建一个 AbilityStage 实例。
- AbilityStage 与 Module 一一对应，即一个 Module 拥有一个 AbilityStage。

DevEco Studio 默认工程中未自动生成 AbilityStage，如需要使用 AbilityStage 的能力，可以手动新建一个 AbilityStage 文件，并在 `module.json5` 配置文件的 `module.srcEntry` 字段指定 AbilityStage 文件的路径。

AbilityStage 的生命周期：

- onCreate：在开始加载对应 Module 的第一个 UIAbility 实例之前会先创建 AbilityStage，并在 AbilityStage 创建完成之后执行其 onCreate()生命周期回调。
- onAcceptWant：UIAbility 指定实例模式（specified）启动时候触发的事件回调。
- onConfigurationUpdate：当系统全局配置发生变更时触发的事件，系统语言、深浅色等。
- onMemoryLevel：当系统调整内存时触发的事件。

```ts
// MyAbilityStage.ts
import AbilityStage from '@ohos.app.ability.AbilityStage'
import hilog from '@ohos.hilog'

export default class MyAbilityStage extends AbilityStage {
  onCreate() {
    hilog.info(0x0000, 'testTag', '%{public}s', 'MyAbilityStage onCreate')
  }

  onAcceptWant() {
    hilog.info(0x0000, 'testTag', '%{public}s', 'MyAbilityStage onAcceptWant')
    return 'MyAbilityStage'
  }

  onConfigurationUpdate() {
    hilog.info(
      0x0000,
      'testTag',
      '%{public}s',
      'MyAbilityStage onConfigurationUpdate'
    )
  }

  onMemoryLevel() {
    hilog.info(0x0000, 'testTag', '%{public}s', 'MyAbilityStage onMemoryLevel')
  }
}
```

## 应用程序入口 —— UIAbility

### UIAbility 概述

- 一种包含用户界面的应用组件，主要用于和用户进行交互。
- 系统调度的单元，为应用提供窗口绘制界面。
- 一个 UIAbility 实例，对应一个最近任务列表中的任务。
- 一个应用可以有一个 UIAbility，也可以有多个 UIAbility。

### UIAbility 的生命周期

当用户浏览、切换和返回到对应的应用的时候，应用中的 UIAbility 实例会在其生命周期的不同状态之间切换。

UIAbility 的生命周期包括 `Create`、`Foreground`、`Background`、`Destroy` 四种状态和 `WindowStageCreate`、`WindowStageDestroy` 窗口管理器（WindowStage）在 UIAbility 中管理 UI 界面功能的两个生命周期回调

- onCreate：在 UIAbility 实例创建时触发。
- onWindowStageCreate：在进入 Foreground 之前。
- onForeground：UIAbility 切换至前台时触发。
- onBackground：UIAbility 切换至后台时触发。
- onWindowStageDestroy：UIAbility 实例销毁之前。
- onDestroy：在 UIAbility 销毁时触发。

![UIAbility生命周期](D:\my-code\mobile-terminal-project\harmonyos-project\harmonyosDemo\md\images\UIAbility生命周期.png)

在项目的 `src/main/ets/entryability` 目录下的 `EntryAbility.ts` 文件中实现 UIAbility 的生命周期回调。

### UIAbility 的启动模式

UIAbility 支持 singleton（单实例模式）、multiton（多实例模式）和 specified（指定实例模式）3 种启动模式。

- singleton（单实例模式）

  singleton 启动模式为单实例模式，也是默认情况下的启动模式。

  系统中只存在唯一一个该 UIAbility 实例，即在最近任务列表中只存在一个该类型的 UIAbility 实例。

- multiton（多实例模式）

  每次打开应用时，都会在应用进程中创建一个新的该类型 UIAbility 实例。即在最近任务列表中可以看到有多个该类型的 UIAbility 实例。

- specified（指定实例模式）

  specified 启动模式为指定实例模式，针对一些特殊场景使用（例如文档应用中每次新建文档希望都能新建一个文档实例，重复打开一个已保存的文档希望打开的都是同一个文档实例）。

### UIAbility 的配置

UIAbility 的配置声明在 `module.json5` 文件的 `module.abilities` 字段。如果希望在桌面上显示该 UIAbility 的图标，则需要在 skills 标签下面的 entities 中添加 `entity.system.home`、actions 中添加 `action.system.home`。

```json
// module.json5
{
  "module": {
    "abilities": [
      {
        "name": "EntryAbility",
        "srcEntry": "./ets/entryability/EntryAbility.ts",
        // "launchType": "standard",
        "description": "$string:EntryAbility_desc",
        "icon": "$media:icon",
        "label": "$string:EntryAbility_label",
        "startWindowIcon": "$media:icon",
        "startWindowBackground": "$color:start_window_background",
        "exported": true,
        "skills": [
          {
            "entities": ["entity.system.home"],
            "actions": ["action.system.home"]
          }
        ]
      },
      {
        "name": "SecondAbility",
        "srcEntry": "./ets/entryability/SecondAbility.ts",
        "description": "$string:SecondAbility_desc",
        "icon": "$media:1",
        "label": "$string:SecondAbility_label",
        "startWindowIcon": "$media:icon",
        "startWindowBackground": "$color:start_window_background"
      }
    ]
  }
}
```

### UIAbility 组件间交互（设备内）

UIAbility 可以启动应用内的其他 UIAbility，也可以启动其他应用的 UIAbility（比如启动微信支付的 UIAbility）。

因为是个人学习，所以不太方便演示调用其他应用的 UIAbility，故只介绍启动应用内的其他 UIAbility。

```ts
import common from '@ohos.app.ability.common';

@Component
export struct AbilityManagement {
  callUIAbility() {
    const wantInfo = {
      deviceId: '', // deviceId为空表示本设备
      bundleName: 'com.example.myapplication',
      abilityName: 'SecondAbility',
      moduleName: 'entry', // moduleName非必选
      parameters: { // 自定义信息
        info: '来自EntryAbility Index页面',
      },
    }
    const context = getContext(this) as common.UIAbilityContext
    context.startAbility(wantInfo)
  }

  build() {
    Column() {
      Button('打开其他UIAbility')
        .onClick(() => {
          this.callUIAbility()
        })
    }
  }
}
```

## ExtensionAbility 组件

ExtensionAbility 组件是基于特定场景提供的应用组件，以便满足更多的使用场景。

每一个具体场景对应一个 ExtensionAbilityType，各类型的 ExtensionAbility 组件均由相应的系统服务统一管理。当前支持开发的 ExtensionAbility 类型有：

- FormExtensionAbility：FORM 类型的 ExtensionAbility 组件，用于提供服务卡片场景相关能力。

- WorkSchedulerExtensionAbility：WORK_SCHEDULER 类型的 ExtensionAbility 组件，用于提供延迟任务注册、取消、查询的能力。

## 信息传递载体 Want

Want 是对象间信息传递的载体，可以用于应用组件间的信息传递。Want 有显示和隐式两种类型。

- 显式 Want：在启动 Ability 时指定了 abilityName 和 bundleName 的 Want 称为显式 Want。

  当有明确处理请求的对象时，通过提供目标 Ability 所在应用的包名信息（bundleName），并在 Want 内指定 abilityName 便可启动目标 Ability。显式 Want 通常用于在当前应用开发中启动某个已知的 Ability。

- 隐式 Want：在启动 UIAbility 时未指定 abilityName 的 Want 称为隐式 Want。

  当请求处理的对象不明确时，希望在当前应用中使用其他应用提供的某个能力（通过 skills 标签定义），而不关心提供该能力的具体应用，可以使用隐式 Want

# 窗口管理（Stage 模型）

HarmonyOS 的窗口模块将窗口界面分为系统窗口和应用窗口两种类型。

- 系统窗口：系统窗口指完成系统特定功能的窗口。如音量条、壁纸、通知栏、状态栏、导航栏等。
- 应用窗口：应用窗口区别于系统窗口，指与应用显示相关的窗口。
  - 应用主窗口：应用主窗口用于显示应用界面，会在"任务管理界面"显示。
  - 应用子窗口：应用子窗口用于显示应用的弹窗、悬浮窗等辅助窗口，不会在"任务管理界面"显示。

## 设置应用主窗口

在 Stage 模型，应用主窗口由 UIAbility 创建并维护生命周期。

- 在应用的配置文件 `module.json5` 设置主窗口的属性。
- 在 UIAbility 的 onWindowStageCreate 回调中，通过 WindowStage 获取应用主窗口，对其进行属性设置。

```ts
export default class EntryAbility extends UIAbility {
  onWindowStageCreate(windowStage: window.WindowStage) {
    // Main window is created, set main page for this ability
    hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onWindowStageCreate')

    // 获取应用主窗口
    let windowClass: null | window.Window = null
    windowStage.getMainWindow((err, data: window.Window) => {
      if (err.code) {
        console.error(
          'Failed to obtain the main window. Cause: ' + JSON.stringify(err)
        )
        return
      }
      windowClass = data
      // 设置状态栏、导航栏是否显示
      windowClass.setWindowSystemBarEnable(['status', 'navigation'])
    })

    // 设置主窗口加载的目标页面
    windowStage.loadContent('pages/Index', this.storage)
  }
}
```

## 设置应用子窗口

1. 创建应用子窗口
2. 设置子窗口属性
3. 设置子窗口加载的目标页面
4. 显示子窗口

```ts
// 创建子窗口
let _windowStage: null | window.WindowStage = null
let subWindowClass: null | window.Window = null

export default class EntryAbility extends UIAbility {
  onWindowStageCreate(windowStage: window.WindowStage) {
    _windowStage = windowStage
  }
}

export function showSubWindow() {
  // 1. 创建应用子窗口
  _windowStage.createSubWindow('mySubWindow', async (err, data) => {
    if (err.code) {
      console.error(
        'Failed to create the subwindow. Cause: ' + JSON.stringify(err)
      )
      return
    }
    subWindowClass = data
    // 设置子窗口的位置、大小等属性
    try {
      await subWindowClass.moveWindowTo(300, 300)
      await subWindowClass.resize(500, 500)
    } catch (err) {
      return console.error(JSON.stringify(err))
    }
    // 3. 设置子窗口加载的目标页面
    subWindowClass.setUIContent('pages/SubWindow', (err) => {
      if (err.code) {
        console.error(
          'Failed to load the content. Cause:' + JSON.stringify(err)
        )
        return
      }
      // 4. 显示子窗口
      subWindowClass.showWindow((err) => {
        if (err.code) {
          console.error(
            'Failed to show the window. Cause: ' + JSON.stringify(err)
          )
          return
        }
        console.info('Succeeded in showing the window.')
      })
    })
  })
}

// 销毁子窗口
export function destorySubWindow() {
  subWindowClass.destroyWindow((err) => {
    if (err.code) {
      console.error(
        'Failed to destroy the window. Cause: ' + JSON.stringify(err)
      )
      return
    }
    console.info('Succeeded in destroying the window.')
  })
}
```

## 设置悬浮窗

全局悬浮窗口是一种特殊的应用窗口，具备在应用主窗口和对应 Ability 退至后台后仍然可以在前台显示的能力。

悬浮窗口可以用于应用退至后台后，使用小窗继续播放视频，或者为特定的应用创建悬浮球等快速入口。

前提条件：需要申请 `ohos.permission.SYSTEM_FLOAT_WINDOW` 权限，在 `module.json5` 文件中配置。

```json
// module.json5
"requestPermissions":[
  {
    "name" : "ohos.permission.SYSTEM_FLOAT_WINDOW",
    "usedScene": {
      "abilities": [
        "EntryAbility"
      ],
      "when": "inuse"
    }
  }
]
```

```ts
struct WindowManagementComponent {
  private windowClass: null | window.Window = null

  // 展示悬浮窗
  showFloatWindow() {
    let config = {
      name: 'floatWindow', windowType: window.WindowType.TYPE_FLOAT, ctx: getContext(this)
    }
    // 1. 创建悬浮窗
    window.createWindow(config, async (err, data: window.Window) => {
      if (err.code) {
        console.error('Failed to create the floatWindow. Cause: ' + JSON.stringify(err));
        return;
      }
      console.info('Succeeded in creating the floatWindow. Data: ' + JSON.stringify(data));
      this.windowClass = data;
      // 2. 设置悬浮窗位置、大小等属性
      try {
        await this.windowClass.moveWindowTo(300, 300)
        await this.windowClass.resize(200, 200)
      } catch (err) {
        return console.error(JSON.stringify(err));
      }

      // 3. 设置悬浮窗加载的目标页面
      this.windowClass.setUIContent('pages/FloatWindow', (err) => {
        if (err.code) {
          console.error('Failed to load the content. Cause:' + JSON.stringify(err));
          return;
        }
        // 4. 显示悬浮窗
        this.windowClass.showWindow((err) => {
          if (err.code) {
            console.error('Failed to show the window. Cause: ' + JSON.stringify(err));
            return;
          }
          console.info('Succeeded in showing the window.');
        })
      })
    })
  }

  // 隐藏悬浮窗
  destoryFloatWindow() {
    this.windowClass.destroyWindow((err) => {
      if (err.code) {
        console.error('Failed to destroy the window. Cause: ' + JSON.stringify(err));
        return;
      }
      console.info('Succeeded in destroying the window.');
    });
  }

  build() {
    Column({ space: 10 }) {
      Button('创建悬浮窗')
        .onClick(() => {
          console.log('create floatWindow')
          this.showFloatWindow()
        })
      Button('销毁悬浮窗')
        .onClick(() => {
          console.log('destory floatWindow')
          this.destoryFloatWindow()
        })
    }
  }
}
```

# 通知

应用可以通过通知接口发送通知消息，终端用户可以通过通知栏查看通知内容，也可以点击通知来打开应用。

HarmonyOS 通过 ANS（Advanced Notification Service，通知系统服务）对通知类型的消息进行管理，支持多种通知类型，如基础类型通知、进度条类型通知。

通知主要有以下使用场景：

- 显示接收到的短消息、即时消息等。
- 显示应用的推送消息，如广告、版本更新等。
- 显示当前正在进行的事件，如下载等。

## 基础类型通知

基础类型通知主要应用于发送短信息、提示信息、广告推送等，支持普通文本类型、长文本类型、多行文本类型和图片类型。

通知的发布和取消都是依赖于 `@ohos.notificationManager` 库提供的接口来实现的：

| 接口名                                                                     | 描述                     |
| -------------------------------------------------------------------------- | ------------------------ |
| publish(request: NotificationRequest, callback: AsyncCallback<void>): void | 发布通知                 |
| cancel(id: number, label: string, callback: AsyncCallback<void>): void     | 取消指定的通知           |
| cancelAll(callback: AsyncCallback<void>): void                             | 取消所有该应用发布的通知 |

发布不同类型的通知由 [NotificationRequest](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-notification-0000001478341329-V3#ZH-CN_TOPIC_0000001523488934__notificationrequest) 的字段携带不同的信息，不同的通知之间的 `id` 必须唯一，更新通知只需调用 `publish` 接口时，`NotificationRequest` 的 `id` 字段一样即可。

## 进度条类型通知

进度条通知主要应用于文件下载、事务处理进度显示。

HarmonyOS 提供了进度条模板，可以先通过 `isSupportTemplate` 判断模板是否存在，如果模板存在，设置好模板的属性值，发送通知。

下面的示例代码模拟了一个完整的进度条通知

```ts
@Component
struct ProgressNotification {
  generateNotificationRequest(progressValue): NotificationManager.NotificationRequest {
    let template = {
      name: 'downloadTemplate',
      data: {
        title: '文件下载',
        fileName: 'music.mp4',
        progressValue,
        progressMaxValue: 100,
      }
    }
    //构造 NotificationRequest对象
    let notificationRequest = {
      id: 2,
      slotType: NotificationManager.SlotType.OTHER_TYPES,
      template: template,
      content: {
        contentType: NotificationManager.ContentType.NOTIFICATION_CONTENT_BASIC_TEXT,
        normal: {
          title: template.data.title + template.data.fileName,
          text: "sendTemplate",
          additionalText: `${progressValue}%`
        }
      },
      deliveryTime: new Date().getTime(),
      showDeliveryTime: true
    }
    return notificationRequest
  }

  async imitateProgressNotification(): Promise<void> {
    try {
      // 判断是否支持某种类型的模板类通知
      const res = await NotificationManager.isSupportTemplate('downloadTemplate')
      if (!res) {
        return
      }
      let progressValue = 0
      let timer = setInterval(async () => {
        if (progressValue >= 100) {
          clearInterval(timer)
        }
        const notificationRequest = this.generateNotificationRequest(progressValue)
        await NotificationManager.publish(notificationRequest)
        progressValue += Math.random() * 10 | 0
        progressValue = Math.min(100, progressValue)
      }, 1000)
    } catch (err) {
      console.error(`[ANS] failed to publish, error[${err}]`)
    }
    console.info(`[ANS] publish success`)
  }

  build() {
    Column({ space: 10 }) {
      Button('模拟完整的进度条通知')
        .onClick(() => {
          this.imitateProgressNotification()
        })
    }
  }
}
```

![进度条通知](D:\my-code\mobile-terminal-project\harmonyos-project\harmonyosDemo\md\images\进度条通知.png)

## 通知组

通知组就是将不同的通知分为不同的组，当同组的通知由多条时，会自动折叠起来。只需要给通知设置 `groupName` 字段就可以进行分组，`groupName` 字段的值相同的通知（不分类型）就是同一个组。

```ts
@Component
struct GroupNotification {
  async sendGroupNotification(): Promise<void> {
    try {
      console.log('group notification')
      const notificationRequest: NotificationManager.NotificationRequest = {
        id: generateId(),
        groupName: 'group',
        content: {
          contentType: NotificationManager.ContentType.NOTIFICATION_CONTENT_BASIC_TEXT, // 普通文本类型通知
          normal: {
            title: '张三',
            text: '晚上一起吃饭呀'
          }
        }
      }
      await NotificationManager.publish(notificationRequest)
      const notificationRequest2: NotificationManager.NotificationRequest = {
        id: generateId(),
        groupName: 'group',
        content: {
          contentType: NotificationManager.ContentType.NOTIFICATION_CONTENT_MULTILINE, // 普通文本类型通知
          multiLine: {
            title: '李四',
            text: '好啊！',
            longTitle: '在叫上其他人一起吧！',
            briefText: '',
            lines: ['王五', '小六']
          }
        }
      }
      await NotificationManager.publish(notificationRequest2)
      const notificationRequest3: NotificationManager.NotificationRequest = {
        id: generateId(),
        groupName: 'group',
        content: {
          contentType: NotificationManager.ContentType.NOTIFICATION_CONTENT_BASIC_TEXT, // 普通文本类型通知
          normal: {
            title: '王五',
            text: '好的'
          }
        }
      }
      await NotificationManager.publish(notificationRequest3)
    } catch (err) {
      console.error(`group notification [ANS] failed to publish, error[${err}]`);
      return;
    }
    console.log(`group notification [ANS] publish success`);
  }

  build() {
    Column() {
      Button('发送一组通知')
        .onClick(this.sendGroupNotification)
    }
  }
}
```

![通知组](D:\my-code\mobile-terminal-projet\harmonyos-project\harmonyosDemo\md\images\通知组.png)

## 给通知添加行为意图

可以给通知添加操作按钮，并给操作按钮添加行为意图来响应点击事件，比如发布公共事件或者拉起一个 UIAbility。

```ts
@Component
struct ActionNotification {
  async handleActionNotification(): Promise<void> {
    try {
      console.log('action notification')
      const wantAgentInfo = {
        wants: [
          {
            bundleName: "com.example.myapplication",
            abilityName: "SecondAbility"
          }
        ],
        operationType: wantAgent.OperationType.START_ABILITY,
        requestCode: 100
      }
      const wantAgentObj = await wantAgent.getWantAgent(wantAgentInfo)
      const notificationRequest: NotificationManager.NotificationRequest = {
        id: generateId(),
        slotType: NotificationManager.SlotType.SOCIAL_COMMUNICATION,
        content: {
          contentType: NotificationManager.ContentType.NOTIFICATION_CONTENT_BASIC_TEXT, // 普通文本类型通知
          normal: {
            title: '通知标题',
            text: '请拉起其他UIAbility'
          }
        },
        actionButtons: [
          {
            title: '拉起UIAbility',
            wantAgent: wantAgentObj
          }
        ]
      }
      await NotificationManager.publish(notificationRequest)
    } catch (err) {
      console.error(`action notification [ANS] failed to publish, error[${err}]`);
      return;
    }
    console.log(`action notification [ANS] publish success`);
  }

  build() {
    Column() {
      Button('拉起其他UIAbility通知')
        .onClick(() => {
          this.handleActionNotification()
        })
    }
  }
}
```

![给通知添加行为](D:\my-code\mobile-terminal-project\harmonyos-project\harmonyosDemo\md\images\给通知添加行为.png)
